#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# This is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# tails. You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.

"""
Nagios CMK Datasource Programm to check Cisco ACI

Authors:    Samuel Zehnder <zehnder@netcloud.ch>
            Roger Ellenberger <roger.ellenberger@wagner.ch>
Version:    0.7

"""

from typing import Dict, List, Set, Optional, Sequence, Tuple, NamedTuple
from dataclasses import dataclass
import logging

import time
import json
from urllib.parse import urljoin
import requests
from os.path import join

from cmk.special_agents.utils.agent_common import SectionWriter, special_agent_main
from cmk.special_agents.utils.argument_parsing import Args, create_default_argument_parser


LOGGING = logging.getLogger("agent_cisco_aci")

requests.packages.urllib3.disable_warnings()

MAX_RETRIES: str = 3
SLEEP_SECONDS: str = 3

VERSION: float = 0.7
NAME: str = "agent_cisco_aci"


@dataclass
class AciNode:
    name: str
    role: str
    state: str
    serial: str
    node_id: str
    health: str = "-1"
    model: str = "unknown"
    descr: str = ""

    def build_node_output(self) -> Tuple:
        if self.role == 'controller':
            node_info = (self.role, self.node_id, self.name, self.state, self.serial,
                         self.model, self.descr)
        else:
            node_info = (self.role, self.node_id, self.name, self.state, self.health,
                         self.serial, self.model, self.descr)

        node_info = tuple(map(str.strip, node_info))  # sanitize strings

        return node_info


class Apic:

    def __init__(self, args) -> None:
        url, session = self._log_into_aci(args)
        self.url = url
        self.session = session

    def _log_into_aci(self, args):
        num_hosts = len(args.host)

        for i, host in enumerate(args.host, start=1):
            url = f'https://{host}/api/'
            try:
                session = self._login(url, args.user, args.password)
                break
            except requests.exceptions.ConnectionError as e:
                self._handle_error(current_host=i, num_hosts=num_hosts,
                                   desc='Could not reach APIC (!!)', error=e, exit_code=2)

            except requests.HTTPError as e:
                self._handle_error(current_host=i, num_hosts=num_hosts,
                                   desc=f'Could not login to ACI, Error: {e.message}', exit_code=3)

            except Exception as e:
                self._handle_error(current_host=i, num_hosts=num_hosts,
                                   desc='Error occurred!', exit_code=3, error=e)

        return url, session

    @staticmethod
    def _login(url, user, pwd) -> requests.Session:
        """APIC Login"""

        creds = {"aaaUser": {"attributes": {"name": user, "pwd": pwd}}}

        counter = 1
        s = requests.Session()
        response = s.post(url + "aaaLogin.json", data=json.dumps(creds), verify=False, timeout=2.000)

        while response.status_code == requests.codes.unauthorized:
            if counter > MAX_RETRIES:
                raise requests.HTTPError(json.loads(response.text)["imdata"][0]["error"]["attributes"]["text"])
            time.sleep(SLEEP_SECONDS)
            response = s.post(url + "aaaLogin.json", data=json.dumps(creds), verify=False, timeout=2.000)
            counter += 1

        response.raise_for_status()

        return s

    @staticmethod
    def _handle_error(current_host: int, num_hosts: int, desc: str, exit_code: int, error: Optional[Exception]):
        if (current_host >= num_hosts):
            LOGGING.error(desc)
            if error:
                LOGGING.error(error)
            exit(exit_code)

    def get_imdata(self, endpoint: str) -> List:
        response = self.session.get(urljoin(self.url, endpoint))
        response.raise_for_status()
        return response.json()['imdata']

    def get_data_from_class(self, aci_class: str) -> List:
        result = self.get_imdata(endpoint=f'class/{aci_class}.json')
        return [item[aci_class]['attributes'] for item in result]

    def get_interface_details(self, dn: str):
        response = self.session.get(urljoin(self.url, f'node/mo/{dn}/phys.json'))
        response.raise_for_status()
        return response.json()['imdata'][0]['ethpmPhysIf']['attributes']


def get_aci_health(apic: Apic):
    """Get Fabric Health Score"""

    imdata = apic.get_imdata('node/mo/topology/health.json')
    health_score = imdata[0]["fabricHealthTotal"]["attributes"]["cur"]

    return int(health_score)


def get_nodes(session, url) -> Dict:
    response = session.get(url + 'node/class/topSystem.json?query-target=self&rsp-subtree=children&'
                           'rsp-subtree-class=eqptCh&rsp-subtree-include=health')
    response.raise_for_status()
    nodes = response.json()['imdata']
    nodelist = dict(spine=[], leaf=[], controller=[])

    for node in nodes:
        aci_node = AciNode(
            name = node['topSystem']['attributes']['name'],
            role = node['topSystem']['attributes']['role'],
            state = node['topSystem']['attributes']['state'],
            serial = node['topSystem']['attributes']['serial'],
            node_id = node['topSystem']['attributes']['id'],
        )

        for child in node['topSystem']['children']:
            if 'healthInst' in child:
                aci_node.health = child['healthInst']['attributes']['cur']
            if 'eqptCh' in child:
                aci_node.descr = child['eqptCh']['attributes']['descr']
                aci_node.model = child['eqptCh']['attributes']['model']

        nodelist[aci_node.role].append(aci_node.build_node_output())

    return nodelist


def get_faults(session, url):
    response = session.get(url + 'node/mo/fltCnts.json')
    response.raise_for_status()
    faults = response.json()['imdata'][0]['faultCountsWithDetails']['attributes']
    return faults['crit'], faults['warn'], faults['maj'], faults['minor']


def get_versions(session, url):
    response = session.get(url + 'node/class/firmwareCtrlrRunning.json')
    response.raise_for_status()
    versions = response.json()['imdata']

    running = []
    for version in versions:
        ctrl_id = version['firmwareCtrlrRunning']['attributes']['dn'].split('/')[2]
        version = version['firmwareCtrlrRunning']['attributes']['version']
        running.append((ctrl_id, version))

    response = session.get(url + 'node/class/firmwareRunning.json')
    response.raise_for_status()
    versions = response.json()['imdata']
    for version in versions:
        node_id = version['firmwareRunning']['attributes']['dn'].split('/')[2]
        version = version['firmwareRunning']['attributes']['version']
        running.append((node_id, version))

    return running


def get_json_section(session, base_url: str, path: str) -> Dict:
    response = session.get(urljoin(base_url, path))
    response.raise_for_status()

    return response.json()['imdata']


def agent_cisco_aci_main(args: Args) -> None:
    """Establish a connection to ACI controller and get version, health, and node information"""

    LOGGING.info("setup HTTPS connection..")
    apic = Apic(args)
    url, session = apic.url, apic.session

    LOGGING.info("write agent header..")
    output_header()

    LOGGING.info("fetch and write version info..")
    output_aci_version(url, session)

    LOGGING.info("fetch and write health status..")
    output_aci_health(apic)

    LOGGING.info("fetch and write node info..")
    output_aci_nodes(url, session)

    #output_aci_class_attributes(
    #    apic, title='bgp_peer_entry', aci_class='bgpPeerEntry',
    #    fields=('addr', 'connAttempts', 'connDrop', 'connEst', 'localIp', 'localPort', 'operSt', 'remotePort', 'type',)
    #)

    output_iface_stats(apic)

    LOGGING.info("all done. cheers.")


def output_aci_nodes(url, session):
    all_nodes = get_nodes(session, url)

    for node_type, nodes in all_nodes.items():
        with SectionWriter(f'aci_{node_type}', separator=' ') as writer:
            for node in nodes:
                writer.append(' '.join(node))


def output_aci_health(apic):
    health_score = get_aci_health(apic)

    with SectionWriter('aci_health', separator=' ') as writer:
        writer.append(f'health {health_score} {" ".join(get_faults(apic.session, apic.url))}')


def output_aci_version(url, session):
    versions = get_versions(session, url)

    with SectionWriter('aci_version', separator=' ') as writer:
        for node, version in versions:
            writer.append(f'{node} {version}')


def output_header():
    with SectionWriter('check_mk', separator=' ') as writer:
        writer.append(f'Version: {NAME}-{VERSION}')
        writer.append('AgentOS: Cisco ACI')


def output_aci_class_attributes(apic: Apic, title: str, aci_class: str, fields: Tuple):
    LOGGING.info(f'fetch and write {title} section')
    results = apic.get_data_from_class(aci_class)

    with SectionWriter(f'aci_{title}', separator=' ') as writer:
        writer.append('#' + (' '.join(fields)))
        if isinstance(results, list):
            for result_obj in results:
                writer.append(prepare_dict_for_writer(result_obj, fields))
        else:
            writer.append(results)


def prepare_dict_for_writer(result_obj: Dict, fields: Tuple) -> str:
    selected_data = [str(result_obj.get(field, 'n/a')) for field in fields]
    return ' '.join(selected_data)


def filter_stats(stats: List, phys_iface_dn: Set):
    return {stats['dn']: stats for stats in stats if stats['dn'] in phys_iface_dn}


class PhysicalInterfaces(NamedTuple):
    phys_iface: List
    ether_stats_filtered: Dict
    dot3_stats_filtered: Dict
    phys_iface_details: Dict

    @staticmethod
    def _build_dn(dn: str, aci_class: str) -> str:
        return join(dn, aci_class)

    def get_ether_stats(self, dn: str) -> Dict:
        dn = self._build_dn(dn, 'dbgEtherStats')
        return self.ether_stats_filtered.get(dn, {})

    def get_dot3_stats(self, dn: str) -> Dict:
        dn = self._build_dn(dn, 'dbgDot3Stats')
        return self.dot3_stats_filtered.get(dn, {})

    def get_phys_iface(self, dn: str) -> Dict:
        dn = self._build_dn(dn, 'phys')
        return self.phys_iface_details.get(dn, {})


class InterfaceDetails(NamedTuple):
    dn: str
    id: str
    admin_state: str
    layer: str
    crc_errors: str
    fcs_errors: str
    op_state: str
    op_speed: str

    def get_interface_details(interface: Dict, data: PhysicalInterfaces):
        iface_dn: str = interface['dn']
        return InterfaceDetails(
            dn=iface_dn,
            id=interface['id'],
            admin_state=interface['adminSt'],
            layer=interface['layer'],
            crc_errors=data.get_ether_stats(iface_dn).get('cRCAlignErrors'),
            fcs_errors=data.get_dot3_stats(iface_dn).get('fCSErrors'),
            op_state=data.get_phys_iface(iface_dn).get('operSt'),
            op_speed=data.get_phys_iface(iface_dn).get('operSpeed'),
        )

    @staticmethod
    def get_header():
        return '#' + (' '.join([
            'dn',
            'id',
            'admin_state',
            'layer',
            'crc_errors',
            'fcs_errors',
            'op_state',
            'op_speed',
        ]))

    def __repr__(self):
        return ' '.join(str(s) for s in [
            self.dn,
            self.id,
            self.admin_state,
            self.layer,
            self.crc_errors,
            self.fcs_errors,
            self.op_state,
            self.op_speed,
        ])


def get_phys_iface(apic: Apic):
    raw_data = __collect_data(apic)
    preprocessed_data = __merge_data(raw_data)

    return preprocessed_data


def __collect_data(apic: Apic):
    phys_iface: List = apic.get_data_from_class(aci_class='l1PhysIf')
    ether_stats: List = apic.get_data_from_class(aci_class='rmonEtherStats')
    dot3_stats: List = apic.get_data_from_class(aci_class='rmonDot3Stats')

    phys_iface_dn: Set = {iface['dn'] for iface in phys_iface}
    ether_stats_filtered: Dict = filter_stats(ether_stats, phys_iface_dn)
    dot3_stats_filtered: Dict = filter_stats(dot3_stats, phys_iface_dn)

    phys_iface_details = {iface['dn']: iface for iface in list(map(apic.get_interface_details, phys_iface_dn))}

    return PhysicalInterfaces(phys_iface, ether_stats_filtered, dot3_stats_filtered, phys_iface_details)


def __merge_data(data: PhysicalInterfaces):
    merged_data = []

    for iface in data.phys_iface:
        merged_data.append(InterfaceDetails.get_interface_details(iface, data))

    return merged_data


def output_iface_stats(apic: Apic):
    iface_stats = get_phys_iface(apic)

    print(InterfaceDetails.get_header())
    for line in iface_stats:
        print(line)


def parse_arguments(argv: Optional[Sequence[str]]) -> Args:
    parser = create_default_argument_parser(description=__doc__)
    parser.add_argument('-H', '--host', type=str, required=True, metavar="HOST", nargs='+',
                        help='APIC IP, multiple IPs (Ctrls) accepted')
    parser.add_argument('-u', '--user', type=str, required=True, metavar="USER", help='ACI Username')
    parser.add_argument('-p', '--password', type=str, required=True, metavar="PASSWORD", help='ACI Password')

    return parser.parse_args(argv)


if __name__ == "__main__":
    """Main entry point to be used"""
    special_agent_main(parse_arguments, agent_cisco_aci_main)
